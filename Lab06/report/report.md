---
## Front matter
title: "Отчёт по лабораторной работе №6"
subtitle: "Управление процессами"
author: "Сулейм Гамбердов"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true
toc-depth: 2
lof: true
lot: true
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
    - spelling=modern
    - babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float}
  - \floatplacement{figure}{H}
---

# Цель работы

Получить навыки управления процессами операционной системы.

# Ход выполнения

## Управление заданиями

1. С помощью команды *su* получены права суперпользователя.  

2. В фоновом режиме запущены два задания:  
   - команда **sleep 3600 &** создала процесс ожидания на 1 час,  
   - команда **dd if=/dev/zero of=/dev/null &** инициировала бесконечную запись нулевых данных в устройство */dev/null*.  

   Третья команда **sleep 7200** (ожидание на 2 часа) была запущена без амперсанда, что привело к блокировке терминала.  

   ![Запуск фоновых и приостановленного процесса](Screenshot_1.png){ #fig:001 width=80% }

3. С помощью сочетания **Ctrl+Z** выполнение процесса *sleep 7200* было приостановлено, а команда *jobs* показала три активных задания:  
   - два в состоянии *Running*,  
   - одно в состоянии *Stopped*.  

4. Для возобновления приостановленного задания в фоне использована команда **bg 3**. Повторный вызов *jobs* подтвердил, что все процессы выполняются в фоновом режиме.  

5. Перемещение первого задания на передний план выполнено с помощью команды **fg 1**, после чего оно было завершено комбинацией **Ctrl+C**.  

6. Аналогичным образом завершены задания 2 и 3 с использованием *fg* и прерывания **Ctrl+C**.  

   ![Управление заданиями с помощью fg и завершение процессов](Screenshot_2.png){ #fig:002 width=80% }

7. В новом терминале, под обычным пользователем, был запущен процесс **dd if=/dev/zero of=/dev/null &**.  

   ![Запуск dd в фоновом режиме под обычным пользователем](Screenshot_3.png){ #fig:003 width=80% }

8. После выхода из терминала процесс продолжил выполняться в системе. Проверка с помощью команды **top** показала активность процесса *dd*, полностью загружающего процессор.  

   ![Процесс dd в списке top](Screenshot_4.png){ #fig:004 width=80% }

9. Повторный запуск **top** и использование встроенной команды *k* позволили завершить процесс *dd*. После этого список процессов обновился, и задание исчезло.  

   ![Завершение процесса dd из top](Screenshot_5.png){ #fig:005 width=80% }

## Управление процессами

1. С помощью команды *su* получены права администратора.  

2. В фоновом режиме запущены три ресурсоёмких процесса:  
   - **dd if=/dev/zero of=/dev/null &**  
   - **dd if=/dev/zero of=/dev/null &**  
   - **dd if=/dev/zero of=/dev/null &**  

   Каждый процесс выполняет бесконечную запись нулевых данных в устройство */dev/null*.  

   ![Запуск трёх процессов dd](Screenshot_6.png){ #fig:006 width=80% }

3. Для отображения информации о запущенных процессах использована команда **ps aux | grep dd**.  
   В результате показаны строки, содержащие *dd*, среди которых последними идут активные процессы.  

4. Для изменения приоритета одного из процессов применена команда **renice -n 5 \<PID\>**, где \<PID\> — идентификатор одного из процессов *dd*. Приоритет был изменён с 0 на 5.  

5. С помощью команды **ps fax | grep -B5 dd** получено дерево процессов.  
   Так как *ps fax* выводит иерархию, стало видно, что все процессы *dd* являются дочерними по отношению к оболочке *bash*, запущенной от имени root.  

6. Для завершения сразу всех процессов *dd* был найден PID родительской оболочки и выполнена команда **kill -9 \<PID\>**. После этого оболочка root закрылась, а вместе с ней завершились и все дочерние процессы *dd*.  

   ![Завершение процессов dd через остановку родительской оболочки](Screenshot_7.png){ #fig:007 width=80% }

## Задание 1. Управление приоритетами процессов

1. С помощью *su* получены права суперпользователя.  

2. В фоновом режиме трижды запущена команда **dd if=/dev/zero of=/dev/null &**.  
   Каждый процесс выполняет бесконечную запись нулевых данных в устройство */dev/null*.  

   ![Запуск трёх процессов dd](Screenshot_8.png){ #fig:008 width=80% }

3. Для одного из процессов изменён приоритет с 0 на 5 с помощью команды  
   **renice -n 5 \<PID\>**.  

4. При повторном изменении приоритета того же процесса команда **renice -n 15 \<PID\>** задала новое значение — 15.  
   Разница заключается в том, что большее положительное значение приоритета означает меньший приоритет выполнения.  
   Процесс с *nice=15* будет получать меньше процессорного времени по сравнению с процессами с более низким значением.  

5. Для завершения всех запущенных процессов *dd* использована команда **killall dd**. Все процессы успешно остановлены.  

## Задание 2. Работа с программой yes и управлением процессами

1. В фоновом режиме запущена программа **yes** с перенаправлением вывода в */dev/null*.  

2. Программа **yes** запущена на переднем плане с подавлением вывода. Выполнение было приостановлено (**Ctrl+Z**), затем процесс переведён в фоновый режим и завершён.  

   ![Запуск и остановка программы yes](Screenshot_9.png){ #fig:009 width=80% }

3. Программа **yes** запущена на переднем плане без подавления вывода. После приостановки и последующего возобновления процесс был завершён.  

4. С помощью команды **jobs** проверены состояния заданий: одно выполняется в фоне, другое — остановлено.  

   ![Состояния заданий в jobs](Screenshot_10.png){ #fig:010 width=80% }

5. Один из фоновых процессов был переведён на передний план командой **fg**, после чего завершён (**Ctrl+C**).  

6. Остановленный процесс был возобновлён в фоне с помощью команды **bg**. Теперь он выполняется в состоянии *Running*.  

7. Для запуска процесса, который продолжит выполняться после выхода из терминала, использована команда **nohup yes > /dev/null &**.  

8. После выхода и повторного входа в консоль проверка с помощью **top** показала, что процесс *yes* продолжает работать.  

   ![Процесс yes в списке top](Screenshot_11.png){ #fig:011 width=80% }

9. Запущено ещё три процесса **yes > /dev/null &**. Два из них были завершены: один по PID командой **kill**, другой по номеру задания через **kill -\<номер\>**.  

10. Для эксперимента с сигналами отправлен сигнал **SIGHUP**:  
    - процессу, запущенному через *nohup* — он продолжил работу,  
    - обычному процессу — он завершился.  

11. Вновь запущено несколько процессов **yes > /dev/null &**, после чего все они были завершены одной командой **killall yes**.  

   ![Массовое завершение процессов yes](Screenshot_12.png){ #fig:012 width=80% }

12. Для сравнения приоритетов запущены два процесса:  
    - обычный **yes > /dev/null &**,  
    - с приоритетом **nice -n 5 yes > /dev/null &**.  

    С помощью команды **ps -l | grep yes** проверены их приоритеты (*PRI* и *NI*). Видно, что второй процесс получил более низкий приоритет.  

13. Командой **renice -n 5 \<PID\>** приоритет одного из процессов изменён так, чтобы оба процесса имели одинаковые значения.  

   ![Изменение приоритета процессов yes](Screenshot_13.png){ #fig:013 width=80% }


# Контрольные вопросы

1. Для получения обзора всех текущих заданий оболочки используется команда **jobs**.  
   Она показывает список процессов, запущенных в рамках текущей сессии, их состояния (*Running*, *Stopped*) и номера.  

2. Чтобы остановить текущее задание и продолжить его выполнение в фоне, применяют комбинацию **Ctrl+Z**, а затем команду **bg \<номер_задания\>**.  

3. Для отмены (прерывания) текущего задания используется комбинация **Ctrl+C**.  

4. Если доступ к оболочке, в которой работает пользователь, невозможен, завершить задание можно через другой терминал, используя **kill \<PID\>** или **killall \<имя_процесса\>**.  

5. Для отображения отношений между родительскими и дочерними процессами используется команда **ps fax** или её аналог **pstree**.  

6. Чтобы изменить приоритет процесса с идентификатором 1234 на более высокий, используется команда:  
   **renice -n -5 -p 1234**  
   (отрицательное значение повышает приоритет процесса).  

7. Если в системе запущено 20 процессов **dd**, проще всего завершить их всех одной командой:  
   **killall dd**  

8. Чтобы остановить процесс с именем *mycommand*, применяется команда:  
   **killall mycommand**  

9. В утилите **top** для завершения процесса используется клавиша **k**, после чего вводится PID процесса, который нужно завершить.  

10. Чтобы запустить команду с высоким приоритетом, но при этом не перегружать систему, можно использовать утилиту **nice**, задав умеренно отрицательный приоритет. Например:  
    **nice -n -5 команда**  
    Это позволит процессу работать быстрее, но не лишит остальные процессы процессорного времени.  

# Заключение  

В ходе выполнения лабораторной работы были освоены приёмы управления заданиями и процессами в Linux. Изучены способы перевода процессов между фоном и передним планом, завершения их работы разными методами, использования сигналов и изменения приоритетов с помощью *nice* и *renice*. Освоенные приёмы позволяют эффективно администрировать систему и контролировать ресурсы, обеспечивая стабильную работу даже при большом количестве процессов.  
